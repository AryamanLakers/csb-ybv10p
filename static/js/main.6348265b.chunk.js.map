{"version":3,"sources":["App.js","index.js"],"names":["App","useState","flag","setflag","grid","i","row","j","push","visited","Array","fill","forEach","e","a","onclick","col","preventDefault","buttons","target","style","backgroundColor","changeColor","class1","document","querySelector","curr","bfs","queue","length","r","c","slice","Promise","resolve","setTimeout","algostart","pointerEvents","className","onClick","map","rowid","node","nodeid","onMouseEnter","onMouseDown","rootElement","getElementById","ReactDOM","render"],"mappings":"6KAEe,SAASA,IAWtB,IAPA,MAAwBC,oBAAS,GAAjC,mBAAOC,EAAP,KAAaC,EAAb,KAGIC,EAAO,GAIFC,EAAI,EAAGA,EAFR,GAEeA,IAAK,CAE1B,IADA,IAAIC,EAAM,GACDC,EAAI,EAAGA,EAHV,GAGiBA,IACrBD,EAAIE,KAAK,GAEXJ,EAAKI,KAAKF,GAEZ,IAAMG,EAAU,IAAIC,MATZ,IASqBC,MAAK,GAClCF,EAAQG,SAAQ,SAACC,EAAGR,EAAGS,GAAP,OAAcL,EAAQJ,GAAK,IAAIK,MATvC,IASgDC,MAAK,MAG7D,IAAII,EAAU,SAACF,EAAGP,EAAKU,GACrBH,EAAEI,iBACgB,IAAdJ,EAAEK,UACNL,EAAEM,OAAOC,MAAMC,gBAAkB,UAI7BC,EAAc,SAACT,EAAGP,EAAKU,GAC3B,IAAMO,EAAM,aAASjB,EAAT,YAAgBU,GAC5BQ,SAASC,cAAcF,GAAQH,MAAMC,gBAvBzB,WA2BRK,EAAO,SAACb,EAAGP,EAAKU,GACpB,IAAMO,EAAM,aAASjB,EAAT,YAAgBU,GAC5B,OAAOQ,SAASC,cAAcF,GAAQH,MAAMC,iBA0BxCM,EAAG,uCAAG,WAAOd,EAAGP,EAAKU,GAAf,qBAAAF,EAAA,sDACNc,EAAQ,CAAC,CAACtB,EAAKU,IADT,YAGHY,EAAMC,OAAS,GAHZ,kCAIOD,EAAM,GAJb,GAIDE,EAJC,KAIEC,EAJF,KAKRH,EAAQA,EAAMI,MAAM,KAEhBF,EAAI,GAAKA,GA7DT,IA6DmBC,EAAI,GAAKA,GA5D5B,IAqDI,wDASc,UADAL,EAAKb,EAAGiB,EAAGC,GARzB,yDAUJtB,EAAQqB,GAAGC,GAVP,8DAWRtB,EAAQqB,GAAGC,IAAK,EAXR,UAaF,IAAIE,SAAQ,SAACC,GAAD,OAAaC,WAAWD,EAAS,QAb3C,QAcRZ,EAAYT,EAAGiB,EAAGC,GAClBH,EAAMpB,KAAK,CAACsB,EAAI,EAAGC,IACnBH,EAAMpB,KAAK,CAACsB,EAAI,EAAGC,IACnBH,EAAMpB,KAAK,CAACsB,EAAGC,EAAI,IACnBH,EAAMpB,KAAK,CAACsB,EAAGC,EAAI,IAlBX,2DAAH,0DAsBHK,EAAS,uCAAG,WAAOvB,EAAGP,EAAKU,GAAf,SAAAF,EAAA,sDAChBU,SAASC,cAAc,SAASL,MAAMiB,cAAgB,OACtDV,EAAId,EAAGP,EAAKU,GAEZb,GAAQ,GAJQ,2CAAH,0DAQf,OACE,sBAAKmC,UAAU,OAAf,UACE,wBACEC,QAAS,WACPpC,GAAQ,IAFZ,mBAQED,EAoBEE,EAAKoC,KAAI,SAAClC,EAAKmC,GACb,OACE,8BACGnC,EAAIkC,KAAI,SAACE,EAAMC,GACd,OACE,qBACEJ,QAAS,SAAC1B,GAAD,OAAOuB,EAAUvB,EAAG4B,EAAOE,IACpCL,UAAS,YAAOG,EAAP,YAAgBE,EAAhB,eALPF,MArBdrC,EAAKoC,KAAI,SAAClC,EAAKmC,GACb,OACE,8BACGnC,EAAIkC,KAAI,SAACE,EAAMC,GACd,OACE,qBACEC,aAAc,SAAC/B,GACbE,EAAQF,IAEVgC,YAAa,SAAChC,GACZE,EAAQF,IAEVyB,UAAS,YAAOG,EAAP,YAAgBE,EAAhB,eAVPF,SCvGxB,IAAMK,EAActB,SAASuB,eAAe,QAC5CC,IAASC,OACP,cAAC,aAAD,UACE,cAACjD,EAAD,MAEF8C,I","file":"static/js/main.6348265b.chunk.js","sourcesContent":["import \"./styles.css\";\nimport { useState, useEffect } from \"react\";\nexport default function App() {\n  //we are making a flag to toggle the state\n  //if flag is false it means you can select the blockages\n  //if flag is true, which happens when you push the start button, then click on any tile and algo will start from there\n  const [flag, setflag] = useState(false);\n\n  //making grid and visited grid\n  let grid = [];\n  const color = \"#FFD32D\";\n  let n = 10;\n  let m = 10;\n  for (var i = 0; i < n; i++) {\n    let row = [];\n    for (var j = 0; j < m; j++) {\n      row.push(0);\n    }\n    grid.push(row);\n  }\n  const visited = new Array(n).fill(false);\n  visited.forEach((e, i, a) => (visited[i] = new Array(m).fill(false)));\n\n  //so when we are selecting blockages, we want click and drag kinda feature\n  let onclick = (e, row, col) => {\n    e.preventDefault();\n    if (e.buttons !== 1) return;\n    e.target.style.backgroundColor = \"black\";\n  };\n\n  //this ensures when our algo reaches an unvisited tile, it changes it's color\n  const changeColor = (e, row, col) => {\n    const class1 = `.kk${row}-${col}`; //this is the unique class name that I have given to every tile of the grid\n    document.querySelector(class1).style.backgroundColor = color;\n  };\n\n  //this tells curren tile's color\n  const curr = (e, row, col) => {\n    const class1 = `.kk${row}-${col}`;\n    return document.querySelector(class1).style.backgroundColor;\n  };\n\n  //this our main algorithm that we have implemented recursively\n  const runFillFloodAlgo = async (e, row, col) => {\n    if (row < 0 || col < 0 || row >= m || col >= n) return;\n    const current_color = curr(e, row, col);\n    if (current_color === \"black\") return;\n    if (grid[row][col] === 1) return;\n    if (visited[row][col]) return;\n\n    //we are pausing our algo, to see the actual working\n    await new Promise((resolve) => {\n      setTimeout(resolve, 300);\n    });\n    visited[row][col] = true;\n    changeColor(e, row, col);\n\n    await runFillFloodAlgo(e, row - 1, col);\n    await runFillFloodAlgo(e, row + 1, col);\n    await runFillFloodAlgo(e, row, col - 1);\n    await runFillFloodAlgo(e, row, col + 1);\n    return;\n  };\n\n  //this is also our algorithm but we haven't used recursion, rather we use a queue here\n  const bfs = async (e, row, col) => {\n    let queue = [[row, col]];\n\n    while (queue.length > 0) {\n      const [r, c] = queue[0];\n      queue = queue.slice(1);\n\n      if (r < 0 || r >= n || c < 0 || c >= m) continue;\n      const current_color = curr(e, r, c);\n      if (current_color === \"black\") continue;\n      if (visited[r][c]) continue;\n      visited[r][c] = true;\n\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      changeColor(e, r, c);\n      queue.push([r - 1, c]);\n      queue.push([r + 1, c]);\n      queue.push([r, c - 1]);\n      queue.push([r, c + 1]);\n    }\n  };\n  //this happens when we click a tile after clicking start button, this starts our algorithm\n  const algostart = async (e, row, col) => {\n    document.querySelector(\".grid\").style.pointerEvents = \"none\";\n    bfs(e, row, col);\n    // await runFillFloodAlgo(e, row, col);\n    setflag(false);\n  };\n\n  //we are returning the jsx representing our grid\n  return (\n    <div className=\"grid\">\n      <button\n        onClick={() => {\n          setflag(true);\n        }}\n      >\n        Start\n      </button>\n\n      {!flag\n        ? grid.map((row, rowid) => {\n            return (\n              <div key={rowid}>\n                {row.map((node, nodeid) => {\n                  return (\n                    <div\n                      onMouseEnter={(e) => {\n                        onclick(e, rowid, nodeid);\n                      }}\n                      onMouseDown={(e) => {\n                        onclick(e, rowid, nodeid);\n                      }}\n                      className={`kk${rowid}-${nodeid} node`}\n                    ></div>\n                  );\n                })}\n              </div>\n            );\n          })\n        : grid.map((row, rowid) => {\n            return (\n              <div key={rowid}>\n                {row.map((node, nodeid) => {\n                  return (\n                    <div\n                      onClick={(e) => algostart(e, rowid, nodeid)}\n                      className={`kk${rowid}-${nodeid} node`}\n                    ></div>\n                  );\n                })}\n              </div>\n            );\n          })}\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}